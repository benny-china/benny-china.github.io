<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding JavaScript async/await | My Tech Blog</title>
    <link rel="stylesheet" href="../css/styles.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <h1><a href="../index.html" style="color: inherit; text-decoration: none;">My Tech Blog</a></h1>
                </div>
                <nav>
                    <ul>
                        <li><a href="../index.html">Home</a></li>
                        <li><a href="../about.html">About</a></li>
                        <li><a href="../contact.html">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>

    <main>
        <div class="container">
            <div class="article-header">
                <h1 class="article-title">Understanding JavaScript async/await</h1>
                <div class="article-meta">Published on March 15, 2024 | Category: JavaScript</div>
            </div>

            <div class="article-content">
                <p>Asynchronous programming is an essential topic in modern JavaScript development. From callbacks to Promises, and then to async/await, JavaScript's approach to handling asynchronous operations has evolved significantly. This article explores the principles and best practices of async/await.</p>

                <h2>What is async/await?</h2>
                <p>async/await is syntactic sugar introduced in ES2017 (ES8) that makes asynchronous code look and behave more like synchronous code, significantly improving code readability.</p>

                <h3>Basic Syntax</h3>
                <pre><code>async function fetchUserData(id) {
    try {
        const response = await fetch(`/api/users/${id}`);
        const userData = await response.json();
        return userData;
    } catch (error) {
        console.error('Failed to fetch user data:', error);
        throw error;
    }
}</code></pre>

                <h2>async/await vs Promise</h2>
                <p>Let's compare Promise and async/await syntax through a concrete example:</p>

                <h3>Using Promises:</h3>
                <pre><code>function getUserPosts(userId) {
    return fetch(`/api/users/${userId}`)
        .then(response => response.json())
        .then(user => {
            return fetch(`/api/users/${userId}/posts`);
        })
        .then(response => response.json())
        .then(posts => {
            return posts.map(post => ({
                ...post,
                author: user.name
            }));
        })
        .catch(error => {
            console.error('Error:', error);
            throw error;
        });
}</code></pre>

                <h3>Using async/await:</h3>
                <pre><code>async function getUserPosts(userId) {
    try {
        const userResponse = await fetch(`/api/users/${userId}`);
        const user = await userResponse.json();
        
        const postsResponse = await fetch(`/api/users/${userId}/posts`);
        const posts = await postsResponse.json();
        
        return posts.map(post => ({
            ...post,
            author: user.name
        }));
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}</code></pre>

                <h2>Concurrent Processing</h2>
                <p>When you need to execute multiple asynchronous operations concurrently, you can combine async/await with Promise.all():</p>

                <pre><code>async function fetchMultipleUsers(userIds) {
    try {
        const promises = userIds.map(id => fetch(`/api/users/${id}`));
        const responses = await Promise.all(promises);
        const users = await Promise.all(
            responses.map(response => response.json())
        );
        return users;
    } catch (error) {
        console.error('Failed to fetch users in batch:', error);
        throw error;
    }
}</code></pre>

                <h2>Error Handling Best Practices</h2>
                <p>Proper error handling is crucial when using async/await:</p>

                <pre><code>async function robustDataFetch() {
    let retries = 3;
    
    while (retries > 0) {
        try {
            const data = await fetchData();
            return data;
        } catch (error) {
            retries--;
            if (retries === 0) {
                throw new Error(`Failed to fetch data: ${error.message}`);
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}</code></pre>

                <h2>Common Pitfalls</h2>
                <p>Here are some common mistakes to avoid:</p>

                <h3>Sequential vs Parallel Execution</h3>
                <pre><code>// ❌ Sequential (slower)
async function fetchDataSequentially() {
    const user = await fetchUser();
    const posts = await fetchPosts();
    return { user, posts };
}

// ✅ Parallel (faster)
async function fetchDataInParallel() {
    const [user, posts] = await Promise.all([
        fetchUser(),
        fetchPosts()
    ]);
    return { user, posts };
}</code></pre>

                <h3>Forgetting to Handle Errors</h3>
                <pre><code>// ❌ Unhandled errors
async function badExample() {
    const data = await fetchData(); // Error might be unhandled
    return data;
}

// ✅ Proper error handling
async function goodExample() {
    try {
        const data = await fetchData();
        return data;
    } catch (error) {
        console.error('Error fetching data:', error);
        throw error;
    }
}</code></pre>

                <h2>Advanced Patterns</h2>

                <h3>Async Iteration</h3>
                <pre><code>async function processItemsSequentially(items) {
    const results = [];
    
    for (const item of items) {
        const result = await processItem(item);
        results.push(result);
    }
    
    return results;
}

async function processItemsConcurrently(items) {
    const promises = items.map(item => processItem(item));
    return await Promise.all(promises);
}</code></pre>

                <h3>Timeout Handling</h3>
                <pre><code>function withTimeout(promise, ms) {
    const timeout = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Operation timed out')), ms);
    });
    
    return Promise.race([promise, timeout]);
}

async function fetchWithTimeout(url) {
    try {
        const response = await withTimeout(fetch(url), 5000);
        return response.json();
    } catch (error) {
        if (error.message === 'Operation timed out') {
            console.error('Request timed out');
        }
        throw error;
    }
}</code></pre>

                <h2>Summary</h2>
                <p>async/await makes asynchronous code more readable and maintainable, but keep these points in mind:</p>
                <ul>
                    <li>Always use try/catch for error handling</li>
                    <li>Be mindful of concurrent execution, use Promise.all() when appropriate</li>
                    <li>Avoid using await in loops unless you need sequential execution</li>
                    <li>Remember that async functions always return Promises</li>
                    <li>Consider performance implications of sequential vs parallel execution</li>
                </ul>

                <p>Mastering async/await is essential for modern JavaScript development, enabling you to write more elegant and maintainable asynchronous code.</p>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 My Tech Blog. All rights reserved.</p>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>